# Go实现分布式锁
实现跨服务间的分布式锁,如微服务间如何确保竞态唯一性，k8s中多个pod竞态；

分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现。

场景：实现电商抢购

## 设计规则
- 互斥性  同一时间只有一个客户端拿到锁；
- 避免死锁 
- 容错性 在服务器宕机的时候，锁仍能得到释放或者其他服务器可以进行加锁
- 解锁、加锁必须同一客户端

## 方案
1. 数据库的锁
- 乐观锁
- 悲观锁
2. 使用redis
步骤：
- 客户端加锁：不存在设置key；
- 设置过期时间，避免死锁；
- 客户端设置随机数token，解锁token必须一致；
- 程序出错，解锁；

考虑场景：
1) c1客户端拿到锁，执行延时，此时锁过期删除；c2客户端获取到锁，此时出现两个客户端同时在执行；

解决思路：
- 增加锁的过期时间，但业务执行时间不可预期，有可能网络问题导致超时；
- 监测业务代码线程执行时间，超时续过期时间；

2）c1获取到锁，其他客户端需要不断去尝试加锁，直到c1释放锁，对于高并发场景比较耗服务器资源
- 加锁设置间隔时间。并发情况下也不乐观；
- 延时队列。获取锁失败，客户端延时获取锁释放消息；c1释放锁发布消息，
- 发布订阅功能，获取锁失败，订阅锁释放消息；c1释放锁发布消息；

code：
- [redis分布式锁](https://github.com/gooopher/go-insight/blob/develop/skill/structure/distribute/redis_lock_test.go)

参考：https://redisbook.readthedocs.io/en/latest/feature/pubsub.html

3. 使用zookeeper

https://juejin.im/post/6844903729406148622

- [ ] 有时间研究下zookeeper的使用。